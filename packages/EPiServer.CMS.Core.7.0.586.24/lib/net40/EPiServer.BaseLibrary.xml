<?xml version="1.0"?>
<doc>
    <assembly>
        <name>EPiServer.BaseLibrary</name>
    </assembly>
    <members>
        <member name="T:EPiServer.BaseLibrary.Collections.SimpleList`1">
            <summary>
            Implementation of a single-linked list.
            </summary>
            <typeparam name="TObject">The type of the object stored in the list.</typeparam>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.Add(`0)">
            <summary>
            Adds the specified item to the list.
            </summary>
            <param name="item">The item to add.</param>
            <remarks>
            <para>This operation is an O(1) operation.</para>
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.InsertLast(`0)">
            <summary>
            Inserts the item at the end of the list.
            </summary>
            <param name="item">The item to insert.</param>
            <remarks>
            <para>This operation is an O(1) operation.</para>
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.InsertFirst(`0)">
            <summary>
            Inserts the item at the start of the list.
            </summary>
            <param name="item">The item to insert.</param>
            <remarks>
            <para>This operation is an O(1) operation.</para>
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.RemoveFirst">
            <summary>
            Removes the first item from the list.
            </summary>
            <returns>The removed item. If no item existed it returns null.</returns>
            <remarks>
            <para>This operation is an O(1) operation.</para>
            <para>Note that there is no way to distinguish between the case where the list contained an item 
            with the value null versus the case where there was no item to remove. Both cases will return null.</para>
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.RemoveLast">
            <summary>
            Remove last item from the list
            </summary>
            <returns>The removed item. If no item existed it returns null.</returns>
            <remarks>
            <para>This operation is an O(n) operation where n is the numer of items in the list. If possible 
            this method should be avoided since all other operations on this class are O(1) operations.</para>
            <para>Note that there is no way to distinguish between the case where the list contained an item 
            with the value null versus the case where there was no item to remove. Both cases will return null.</para>
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the list.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <remarks>
            Even though the enumerator has no locking semantics, it is safe for multithreaded use.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <remarks>
            Even though the enumerator has no locking semantics, it is safe for multithreaded use.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
            <returns>
            The index of <paramref name="item"/> if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.Insert(System.Int32,`0)">
            <summary>
            Always thows a <see cref="T:System.NotImplementedException"/> since the method is not supported by SimpleList.
            <para>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
            </para>
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SimpleList`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            true if <paramref name="item"/> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false. This method also returns false if <paramref name="item"/> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <exception cref="T:System.NotSupportedException">
            The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </exception>
        </member>
        <member name="P:EPiServer.BaseLibrary.Collections.SimpleList`1.IsSynchronized">
            <summary>
            Gets a value indicating whether this instance is synchronized.
            </summary>
            <value>
            	<c>true</c> if this instance is synchronized; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:EPiServer.BaseLibrary.Collections.SimpleList`1.Count">
            <summary>
            Gets the count of items in the list.
            </summary>
            <value>The count.</value>
            <remarks>
            Note that this property is calculated by iterating over the list. I e it is expensive on large lists.
            </remarks>
        </member>
        <member name="P:EPiServer.BaseLibrary.Collections.SimpleList`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
            </summary>
            <returns>Alwways true, since SimpleList does not support Read-only.
            </returns>
        </member>
        <member name="T:EPiServer.BaseLibrary.Collections.SynchronizedSimpleList`1">
            <summary>
            Implementation of a thread-safe single-linked list.
            </summary>
            <typeparam name="TObject">The type of the object.</typeparam>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SynchronizedSimpleList`1.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SynchronizedSimpleList`1.InsertLast(`0)">
            <summary>
            Inserts the item at the end of the list.
            </summary>
            <param name="item">The item to insert.</param>
            <remarks>This operation is an O(1) operation.</remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SynchronizedSimpleList`1.InsertFirst(`0)">
            <summary>
            Inserts the item at the start of the list.
            </summary>
            <param name="item">The item to insert.</param>
            <remarks>This operation is an O(1) operation.</remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SynchronizedSimpleList`1.RemoveLast">
            <summary>
            Remove last item from the list
            </summary>
            <returns>
            The removed item. If no item existed it returns null.
            </returns>
            <remarks>
            	<para>This operation is an O(n) operation where n is the numer of items in the list. If possible
            this method should be avoided since all other operations on this class are O(1) operations.</para>
            	<para>Note that there is no way to distinguish between the case where the list contained an item
            with the value null versus the case where there was no item to remove. Both cases will return null.</para>
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Collections.SynchronizedSimpleList`1.RemoveFirst">
            <summary>
            Removes the first item from the list.
            </summary>
            <returns>
            The removed item. If no item existed it returns null.
            </returns>
            <remarks>
            	<para>This operation is an O(1) operation.</para>
            	<para>Note that there is no way to distinguish between the case where the list contained an item
            with the value null versus the case where there was no item to remove. Both cases will return null.</para>
            </remarks>
        </member>
        <member name="P:EPiServer.BaseLibrary.Collections.SynchronizedSimpleList`1.IsSynchronized">
            <summary>
            Gets a value indicating whether this instance is synchronized.
            </summary>
            <value>
            	<c>true</c> if this instance is synchronized; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:EPiServer.BaseLibrary.ArgumentException">
            <summary>
            Summary description for ArgumentException.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.BaseException">
            <summary>
            Summary description for ElektroPostException.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Channel.ChannelEventArgs">
            <summary>
            Summary description for ChannelEventArgs.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Channel.ChannelEventHandler">
            <summary>
            Summary description for ChannelEventHandler.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Channel.IChannel">
            <summary>
            Summary description for IChannel.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.ClassFactory">
            <summary>
            Class factory for the basic classes for object storage and retrieval.
            </summary>
            <remarks>
            Note that ClassFactory must be initialized by assigning the <see cref="P:EPiServer.BaseLibrary.ClassFactory.Instance"/> property
            an instantiated object that implements the <see cref="T:EPiServer.BaseLibrary.IClassFactory"/> interface. This will
            usually be performed by config-file based configuration, but can be made manually.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactory.CreateInstance(System.Type,System.Object[])">
            <summary>
            Create the object implementation for the requested type.
            </summary>
            <param name="baseType">The interface or base class that we request an object instance for.</param>
            <param name="constructorParameters">Optional parameters to pass to a constructor.</param>
            <returns>The created object instance.</returns>
            <remarks>
            This method should be considered a "last resort" when creating objects from application-level code.
            Object creation should be wrapped by more specific class factory objects that can handle constructor-
            based object creation.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactory.RegisterClass(System.Type,System.Type)">
            <summary>
            Register an implementation class for an interface/base class.
            </summary>
            <param name="baseType">The interface or base class.</param>
            <param name="mappedType">The class that implements the baseType interface or inherits from baseType.</param>
            <remarks>
            Note that mappedType must implement the interface identified by baseType or inherit from baseType.
            mappedType must also be a concrete class with a default constructor.
            <para>
            If baseType has already been registered, the old registration will be overwritten with the new 
            parameters.
            </para>
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactory.IsRegistered(System.Type)">
            <summary>
            Check if a type has been registered.
            </summary>
            <param name="baseType">The interface or base class.</param>
            <retuens>True if the type is registered.</retuens>
            <remarks>
            Will only register the mapping if no previous registration for baseType exists.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactory.ClearRegistrations">
            <summary>
            Remove all class registrations.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactory.CreateContext">
            <summary>
            Create a context object.
            </summary>
            <returns>An object instance that implements <see cref="T:EPiServer.BaseLibrary.IContext"/>.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactory.CreateRepository">
            <summary>
            Create a repository object.
            </summary>
            <returns>An object instance that implements <see cref="T:EPiServer.BaseLibrary.IRepository"/>.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactory.CreateSession">
            <summary>
            Create a session object.
            </summary>
            <returns>An object that implements <see cref="T:EPiServer.BaseLibrary.ISession"/>.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactory.CreateSession(EPiServer.BaseLibrary.IObjectStore)">
            <summary>
            Create a session object.
            </summary>
            <param name="objectStore">The object store to create a session for.</param>
            <returns>An object that implements <see cref="T:EPiServer.BaseLibrary.ISession"/>.</returns>
        </member>
        <member name="P:EPiServer.BaseLibrary.ClassFactory.Instance">
            <summary>
            The actual class factory instance.
            </summary>
            <remarks>
            Accessing the Instance getter without first setting it will cause a ClassFactoryException. 
            To check if the class factory has been initialized you can look at the <see cref="P:EPiServer.BaseLibrary.ClassFactory.IsInitialized"/>
            property.
            </remarks>
        </member>
        <member name="P:EPiServer.BaseLibrary.ClassFactory.IsInitialized">
            <summary>
            Check if class factory has been initialized.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.ClassFactoryException">
            <summary>
            Summary description for ClassFactoryException.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.ClassFactoryRegistry">
            <summary>
            Summary description for ClassFactoryCollection.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactoryRegistry.Clear">
            <summary>
            Remove all registered class factories.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactoryRegistry.Factory(System.String)">
            <summary>
            Get a class factory implementation.
            </summary>
            <param name="id">The id of the class factory.</param>
            <returns>An IClassFactory implementation.</returns>
            <remarks>
            The returned class factory is usually specialized to allow for selecting a specific class factory
            from a group of factories that implement the same external interface, but returns different sets
            of created objects.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactoryRegistry.AddFactory(EPiServer.BaseLibrary.IClassFactory)">
            <summary>
            Add a class factory implementation.
            </summary>
            <param name="factory">A class factory instance that implements the IClassFactory interface.</param>
            <remarks>
            The registration is usually done from the application configuration file, but you can register
            class factories from code by calling this method.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.ClassFactoryRegistry.FactoryImplementations(System.Type)">
            <summary>
            Get all factories that implements a specific interface or extends a specific base class.
            </summary>
            <param name="factoryType">The interface or base class that the factory must be assignemnt compatible with.</param>
            <returns></returns>
        </member>
        <member name="T:EPiServer.BaseLibrary.ConfigurationHandler">
            <summary>
            Summary description for ConfigurationHandler.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.ConfigurationHandler.Initialize(System.Configuration.Configuration)">
            <summary>
            Initializes the specified config. 
            This function can be used when you will initialize base library with a specified config.
            </summary>
            <param name="config">The config.</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.ConfigurationHandler.InitializeClass(System.Object,System.Xml.XmlNode)">
            <summary>
            Call Initialize method on instance if it implements the IInitialize interface.
            </summary>
            <param name="instance">An object that may implement <see cref="T:EPiServer.BaseLibrary.IInitialize"/></param>
            <param name="node">The node that contains the type definition used to create instance.</param>
            <remarks>
            The node should be an &lt;add type="...  &gt; node. It may contain sub-nodes and it should primarily
            be those sub-nodes that should carry custom configuration information that is passed to the Initialize
            method.
            </remarks>
        </member>
        <member name="T:EPiServer.BaseLibrary.Context">
            <summary>
            Summary description for Context.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IBaseLibraryFactory">
            <summary>
            Summary description for IBaseLibraryFactory.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IClassFactory">
            <summary>
            Summary description for IClassFactory.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IContext">
            <summary>
            Summary description for IContext.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IContext.FreezeTime(System.DateTime)">
            <summary>
            Lock the time returned by Now.
            </summary>
            <param name="now">The DateTime value to return from Now</param>
            <remarks>
            This time freeze will be in effect until either NormalTime, OffsetTime or another FreezeTime
            call is made. Note that the time settings flows with the current call context, but it will
            not flow across threads.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IContext.OffsetTime(System.TimeSpan)">
            <summary>
            Offset the time returned by Now
            </summary>
            <param name="offset">The TimeSpan value to add to the current time.</param>
            <remarks>
            This time offset will be in effect until either NormalTime, FreezeTime or another OffsetTime
            call is made. Note that the time settings flows with the current call context, but it will
            not flow across threads.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IContext.NormalTime">
            <summary>
            Removes any freeze or offset to the time.
            </summary>
        </member>
        <member name="P:EPiServer.BaseLibrary.IContext.Repository">
            <summary>
            Get the current repository in use for this context.
            </summary>
            <remarks>
            In most cases the repository will be a singleton object for the entire app domain, but
            this is not a requirement.
            </remarks>
        </member>
        <member name="P:EPiServer.BaseLibrary.IContext.Item(System.String)">
            <summary>
            A general-purpose store for context-bound data.
            </summary>
            <remarks>
            If you need specific data to cross application layers and the API:s do not expose
            this functionality, you may use this store to pass such data. Note that the current context
            might not be available to object stores since they may reside in separate app domains or
            even on a different physical machine.
            </remarks>
        </member>
        <member name="T:EPiServer.BaseLibrary.IDecorator">
            <summary>
            The IDecorator is an interface to be used with the decorator pattern to set the component for the decorator.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IDecorator.SetComponent(System.Object)">
            <summary>
            Sets the component (base instance) for the decorator.
            </summary>
            <param name="component">The component - the base instance to call if the functionality should be executed.</param>
        </member>
        <member name="T:EPiServer.BaseLibrary.IInitialize">
            <summary>
            Summary description for IInitializable.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IItem">
            <summary>
            The base interface for all items
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IItemList`2">
            <summary>
            Summary description for IEnumerableItems.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IObjectStore">
            <summary>
            The main interface for object store implementations.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.CreateSessionStore">
            <summary>
            TODO
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.Load(System.Object)">
            <summary>
            Load item with the given identity.
            </summary>
            <param name="id">The item identity.</param>
            <returns>An initialized IItem. Returns null if the item is not found.</returns>
            <remarks>
            This method will only return null if the item does not exist. Any other failure will generate an
            ObjectStoreException.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.LoadPath(System.String,EPiServer.BaseLibrary.IItem)">
            <summary>
            Loads an item given its path.
            </summary>
            <param name="path">The object store path to the item.</param>
            <param name="current">The item to start searching from. Must be null if path is a root path.</param>
            <returns>An initialized IItem. Returns null if the item is not found.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.CreatePath(System.String,EPiServer.BaseLibrary.IItem)">
            <summary>
            Creates a new path or loads an item if the path exists.
            </summary>
            <param name="path">The object store path to create.</param>
            <param name="current">The item to start creating from.  Must be null if path is a root path.</param>
            <returns>An initialized IItem.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.Save(EPiServer.BaseLibrary.IItem)">
            <summary>
            Saves an item.
            </summary>
            <param name="item">The item to save.</param>
            <returns>True if the item was created in the object store, False if an existing item was updated.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.Delete(System.Object)">
            <summary>
            Deletes an item. If the item does not exist, just returns.
            </summary>
            <param name="id">The identity of the item to delete.</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.OpenConnection">
            <summary>
            Acquire the resources needed to access the underlying storage.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.CloseConnection">
            <summary>
            Release any resources needed to access the underlying storage.
            </summary>
            <remarks>
            The implementation must obey the following assumptions:
            <list>
            <item>No connection has been opened</item><description>Do nothing</description>
            <item>A transaction is open (BeginTransaction has been called, but no corresponding CommitTransaction or RollbackTransaction)</item><description>Commit the transaction</description>
            </list>
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.BeginTransaction">
            <summary>
            Start a new transaction for the current connection.
            </summary>
            <remarks>
            If there is already an active transaction for this connection, do nothing.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.CommitTransaction">
            <summary>
            Commit the current transaction.
            </summary>
            <remarks>
            If there is no active transaction, do nothing.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.RollbackTransaction">
            <summary>
            Rollback the current transaction.
            </summary>
            <remarks>
            If there is no active transaction, do nothing.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.ExecuteQueryId``1(EPiServer.BaseLibrary.Search.Query)">
            <summary>
            Executes a query and returns a list of the identities of the matching items.
            </summary>
            <typeparam name="ITEMTYPE">The type of items to include in the search.</typeparam>
            <param name="query">The query.</param>
            <returns>A list of item identities.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.ExecuteQueryObject``1(EPiServer.BaseLibrary.Search.Query)">
            <summary>
            Executes a query and returns a list of the matching items.
            </summary>
            <typeparam name="ITEMTYPE">The type of items to include in the search.</typeparam>
            <param name="query">The query.</param>
            <returns>A list of ITEMTYPE items.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.RelatedItemsFrom(System.Object)">
            <summary>
            Returns all items with a relation from a specific item.
            </summary>
            <param name="fromId">The identity of the item to find relations from.</param>
            <returns>A list of items.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.RelatedItemsFrom``1(System.Object)">
            <summary>
            Returns all items of a specific type with a relation from a specific item.
            </summary>
            <typeparam name="ITEMTYPE">The type of items to find.</typeparam>
            <param name="fromId">The identity of the item to find relations from.</param>
            <returns>A list of ITEMTYPE items.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.RelatedItemsTo(System.Object)">
            <summary>
            Returns all items with a relation to a specific item.
            </summary>
            <param name="toId">The identity of the item to find relations to.</param>
            <returns>A list of items.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.RelatedItemsTo``1(System.Object)">
            <summary>
            Returns all items of a specific type with a relation from a specific item.
            </summary>
            <typeparam name="ITEMTYPE">The type of items to find.</typeparam>
            <param name="toId">The identity of the item to find relations to.</param>
            <returns>A list of ITEMTYPE items.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.AddRelation(System.Object,System.Object)">
            <summary>
            Adds a relation from one object to another.
            </summary>
            <param name="fromId">The source object of the relation.</param>
            <param name="toId">The destination object of the relation.</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.IObjectStore.RemoveRelation(System.Object,System.Object)">
            <summary>
            Removes an existing relation between two objects.
            </summary>
            <param name="fromId">The source object of the relation.</param>
            <param name="toId">The destination object of the relation.</param>
        </member>
        <member name="P:EPiServer.BaseLibrary.IObjectStore.ObjectStoreId">
            <summary>
            A unique identity for the specific instance of an object store.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IO.Crc32">
            <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the
            same polynomial used by Zip.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.Crc32.GetCrc32(System.IO.Stream)">
            <summary>
            Returns the CRC32 for the specified stream.
            </summary>
            <param name="input">The stream over which to calculate the CRC32</param>
            <returns>the CRC32 calculation</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.Crc32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream,System.Int32@)">
            <summary>
            Returns the CRC32 for the specified stream, and optionally writes the input into the output stream.
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <param name="totalBytesRead"></param>
            <returns></returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.Crc32.#cctor">
            <summary>
            Initialize lookup table.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.Compression.Zip.ZipFile.Read(System.String)">
            <summary>
            This will throw if the zipfile does not exist. 
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.Compression.Zip.ZipFile.Read(System.String,System.Boolean)">
            <summary>
            This will throw if the zipfile does not exist. 
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream">
            <summary>
            Readable and writeable stream implementation backed by a pooled memory area
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream._position">
            <summary>
            The current Position in the stream for next read or write
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream._length">
            <summary>
            The total length of the stream. Updated at Write, not when position is set.
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream._disposed">
            <summary>
            True when we're already disposed
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream._closed">
            <summary>
            True when we're closed
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream._bufferArea">
            <summary>
            The backing store of memory buffers
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.#ctor(EPiServer.BaseLibrary.MemoryBufferPool)">
            <summary>
            Initializes a new instance of the PooledMemoryBufferStream class 
            </summary>
            <param name="pool">Use this pool to allocate memory from</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Close">
            <summary>
            Close the stream and Dispose() of the memory buffers
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Flush">
            <summary>
            Do nothing
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Set the position of next read and write
            </summary>
            <param name="offset">Whence the seek is relative to</param>
            <param name="origin">The amount to seek from the offset</param>
            <returns>The new position</returns>
            <remarks>
            No actual allocation of space is done by Seeking
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.SetLength(System.Int64)">
            <summary>
            Set the length of stream.
            </summary>
            <param name="value">The length</param>
            <remarks>
            No actual allocation of space is done, this just limits how far you can read
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from the stream
            </summary>
            <param name="buffer">Where to put the result</param>
            <param name="offset">Offset into the buffer to place the result</param>
            <param name="count">How many bytes to read</param>
            <returns>The actual number of bytes read. 0 for end of file.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write to the stream
            </summary>
            <param name="buffer">The buffer to write from</param>
            <param name="offset">The offset in the buffer to start from</param>
            <param name="count">The number of bytes to write</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream"/> is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Dispose">
            <summary>
            Releases all resources used by the <see cref="T:System.IO.Stream"></see>.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Dispose(System.Boolean)">
            <summary>
            Clean up. This is important since we want to keep track of re-usable buffers from the
            backing memory store.
            </summary>
            <param name="disposing">true of called via Dispose(), false if called by framework Finalize()</param>
        </member>
        <member name="P:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.CanRead">
            <summary>
            True if not closed
            </summary>
        </member>
        <member name="P:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.CanSeek">
            <summary>
            True if not closed
            </summary>
        </member>
        <member name="P:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.CanWrite">
            <summary>
            True if not closed
            </summary>
        </member>
        <member name="P:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Length">
            <summary>
            The length of the stream. (How many bytes you can read from position 0).
            </summary>
        </member>
        <member name="P:EPiServer.BaseLibrary.IO.PooledMemoryBufferStream.Position">
            <summary>
            Gets or sets the next position to read or write from or to.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IRepository">
            <summary>
            Summary description for IRepository.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.ISession">
            <summary>
            Summary description for ISession.
            </summary>
            <remarks>
            An ISession implementation is required to have a constructor with the signature 
            (IObjectStore sessionStore, IRepository repository).
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.ISession.Load(System.Object)">
            <summary>
            Load an object.
            </summary>
            <param name="id">Id of the object to load.</param>
            <returns>The instantiated object. Null if the object does not exist.</returns>
            <remarks>
            Note that two consecutive calls to Load with the same id may yield different results.
            The first call may return the object and the second call may return null because the
            object has been deleted.
            Even if the second call succeeds the Load method may return two different object instances
            (this behavior is implementation dependent), so the only way to check for two references 
            holding reference to the "same" object is to compare the id.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.ISession.Save(EPiServer.BaseLibrary.IItem)">
            <summary>
            Save item.
            </summary>
            <param name="item">The item to save.</param>
            <returns>True if the item was created in the object store, False it an existing item was updated.</returns>
        </member>
        <member name="T:EPiServer.BaseLibrary.MemoryBufferPool">
            <summary>
            Handle a pool of large memory buffers
            </summary>
            <remarks>
            The buffers will be at least 87040 bytes (>85000 so as to go into the large
            object heap)
            </remarks>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool._defaultBufferSize">
            <summary>
            The default should be larger than the threshold for being placed into the large object heap
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool._performanceCounters">
            <summary>
            The backing store for the <see cref="P:EPiServer.BaseLibrary.MemoryBufferPool.PerformanceCounters"/> property.
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool._bufferSize">
            <summary>
            This size of each buffer to allocate
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool._bufferPool">
            <summary>
            The pool of potentially available buffers.
            </summary>
            <remarks>
            The idea of using a stack is that we will tend to re-use recently used ones, which increases
            the likelyhood of finding one quick, and also lets the garbage collector collect buffers beyond
            the high-water mark
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.MemoryBufferPool.#ctor(System.Int32)">
            <summary>
            Construct a pool. It is thread safe.
            </summary>
            <param name="bufferSize">The size of each buffer. May be rounded upwards - always check the buffer Lenth property</param>
            <remarks>
            The normal case is to have static field representing the pool so that many threads can share it.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.MemoryBufferPool.#ctor">
            <summary>
            Construct a pool with a default memory buffer size. It is thread safe.
            </summary>
            <remarks>
            The normal case is to have static field representing the pool so that many threads can share it.
            </remarks>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool._instance">
            <summary>
            The singleton instance, created in the static constructor.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.MemoryBufferPool.Allocate">
            <summary>
            Get a buffer. There is no guarantee of the size returned.
            </summary>
            <returns>A buffer. Check the Length property to know how large it is.</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.MemoryBufferPool.ReleaseOne(System.Object)">
            <summary>
            Release one single buffer - without locking! Must be done by caller.
            </summary>
            <param name="o">An object, presumed but not checked, to be a byte[]</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.MemoryBufferPool.Release(System.Byte[])">
            <summary>
            Actively re-release a buffer. Do not use it afterwards - it may be re-used at any time.
            </summary>
            <param name="theBuffer">A buffer that you want re-used. It does not need to allocated by this manager.</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.MemoryBufferPool.Release(System.Collections.ArrayList)">
            <summary>
            Acitvely re-release an ArrayList of buffers. Do not use these afterwards. The ArrayList is cleared.
            </summary>
            <param name="theBuffers">An ArrayList of byte[]'s. Cleared after call</param>
            <remarks>
            This method is to optimize for the case we have many buffers, since we'll do it all in one lock
            </remarks>
        </member>
        <member name="P:EPiServer.BaseLibrary.MemoryBufferPool.PerformanceCounters">
            <summary>
            Gets the collection of performance counters
            </summary>
        </member>
        <member name="P:EPiServer.BaseLibrary.MemoryBufferPool.Instance">
            <summary>
            Gets the singleton instance.
            It is thread-safe.
            </summary>
            <value>The instance.</value>
            <remarks>
            Whenever a MemoryBufferPool is required, it is recommended to use the singleton instance
            available here, as it allows for efficient sharing and re-use of buffers. Only if a pool
            requiring significantly different characterstics should a new pool be instantiated.
            </remarks>
        </member>
        <member name="T:EPiServer.BaseLibrary.MemoryBufferPool.Counters">
            <summary>
            Collection of performance counters
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool.Counters.HighWaterMark">
            <summary>
            The most number of buffers that we have had saved for re-use
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool.Counters.BuffersAllocated">
            <summary>
            The total numbers of buffers allocated
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool.Counters.BuffersAllocatedFromPool">
            <summary>
            The number of buffers that were re-used from the pool
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.MemoryBufferPool.Counters.WeakReferencesReclaimed">
            <summary>
            The number of times a WeakReference was reclaimed by the system before we could re-use
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.ObjectStoreException">
            <summary>
            Summary description for ObjectStoreException.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.PooledMemoryBufferArea">
            <summary>
            Manage a collection of pooled memory buffers such that it is convenient to read
            and write to it, as if it was one large contiguous area.
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.PooledMemoryBufferArea._disposed">
            <summary>
            Keep track of disposed state. It's important to Dispose()
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.PooledMemoryBufferArea.buffers">
            <summary>
            The list of buffers representing the total memory area. No
            assumption is made on the size of each and every buffer.
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.PooledMemoryBufferArea.pool">
            <summary>
            The MemoryBufferPool where we allocate memory from (and release
            it when we're disposed).
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.PooledMemoryBufferArea.poolSize">
            <summary>
            The total capacity of the current pool
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.PooledMemoryBufferArea.currentBufferOffset">
            <summary>
            The offset of the current buffer as defined by currentBufferIndex
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.PooledMemoryBufferArea.currentBufferPosition">
            <summary>
            The offset into the current buffer as defined by currentBufferIndex
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.PooledMemoryBufferArea.currentBufferIndex">
            <summary>
            The index into _buffers for the current buffer (or -1 if not set)
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.PooledMemoryBufferArea.Finalize">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:EPiServer.BaseLibrary.PooledMemoryBufferArea"/> is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.PooledMemoryBufferArea.Dispose">
            <summary>
            Does a release of the buffers to the MemoryPool for potential re-use.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.PooledMemoryBufferArea.Dispose(System.Boolean)">
            <summary>
            You should call Dispose() from your code (which will call here)
            to ensure that memory buffers are returned correctly to the
            pool. If this object is not explicitly disposed, the buffers
            will not be re-used by the pool (but will instead be taken
            by the garbage collector - no leak occurs).
            </summary>
            <param name="disposing">true when called from code, false when called by GC</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.PooledMemoryBufferArea.#ctor(EPiServer.BaseLibrary.MemoryBufferPool)">
            <summary>
            Initializes a new instance of the <see cref="T:EPiServer.BaseLibrary.PooledMemoryBufferArea"/> class.
            </summary>
            <param name="pool">The pool.</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.PooledMemoryBufferArea.ReadOrWrite(System.Int64,System.Byte[],System.Int32,System.Int32,EPiServer.BaseLibrary.PooledMemoryBufferArea.BlockCopyDelegate)">
            <summary>
            Read or Write at a specified location in the buffer list. We maintain state between calls
            to optimize the typical case of sequential writing followed by sequential reading. This also
            allows a stream implementation using this as backing store to manage it's position witout any
            side effects until data is actually written.
            </summary>
            <param name="position">The position.</param>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="count">The count.</param>
            <param name="blockCopy">The block copy delegate determining if we're reading to the parameter buffer or writing to it.</param>
            <returns></returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.PooledMemoryBufferArea.Write(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a buffer of data at the specified position.
            </summary>
            <param name="position">The position.</param>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="count">The count.</param>
            <exception cref="T:EPiServer.BaseLibrary.ArgumentException"/>
            <returns>The number of bytes actually written</returns>
        </member>
        <member name="M:EPiServer.BaseLibrary.PooledMemoryBufferArea.Read(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a buffer of data at the specified position.
            </summary>
            <param name="position">The position.</param>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="count">The count.</param>
            <exception cref="T:EPiServer.BaseLibrary.ArgumentException"/>
            <returns>The number of bytes actually read</returns>
        </member>
        <member name="T:EPiServer.BaseLibrary.PooledMemoryBufferArea.BlockCopyDelegate">
            <summary>
            We need to reverse the argument order depending on reading or writing, thus a delegate for
            the <see cref="M:System.Buffer.BlockCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/> method.
            </summary>
            <param name="array1"></param>
            <param name="offset1"></param>
            <param name="array2"></param>
            <param name="offset2"></param>
            <param name="count"></param>
        </member>
        <member name="T:EPiServer.BaseLibrary.RepositoryException">
            <summary>
            Summary description for RepositoryException.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Scheduling.JobBase">
            <summary>
            Base class for all Scheduled job that supports start and stop
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.Scheduling.JobBase.Execute">
            <summary>
            Execute the job
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.Scheduling.JobBase.Stop">
            <summary>
            Stop the job
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.Scheduling.JobBase.OnStatusChanged(System.String)">
            <summary>
            Raise a StatusChanged event
            </summary>
            <param name="statusMessage">Status message to report</param>
        </member>
        <member name="E:EPiServer.BaseLibrary.Scheduling.JobBase.StatusChanged">
            <summary>
            Event used to report status changes for the Job
            </summary>
        </member>
        <member name="P:EPiServer.BaseLibrary.Scheduling.JobBase.ScheduledJobId">
            <summary>
            Gets the Id of the scheduled job
            </summary>
        </member>
        <member name="P:EPiServer.BaseLibrary.Scheduling.JobBase.IsStoppable">
            <summary>
            Gets/Sets if the job is stoppable
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Scheduling.JobStatusChangedEventArgs">
            <summary>
            Job Status Changed Event arguments
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.Scheduling.JobStatusChangedEventArgs.#ctor(System.String)">
            <summary>
            Initializes a new instance
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="P:EPiServer.BaseLibrary.Scheduling.JobStatusChangedEventArgs.Message">
            <summary>
            Gets the Message
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Search.BetweenExpression">
            <summary>
            Summary description for BetweenExpression.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Search.IExpression">
            <summary>
            Summary description for IExpression.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Search.EqualExpression">
            <summary>
            Summary description for EqExpression.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Search.Expression">
            <summary>
            Summary description for Expression.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Search.Order">
            <summary>
            Summary description for Order.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Search.Query">
            <summary>
            Summary description for Query.
            </summary>
        </member>
        <member name="T:EPiServer.Security.AccessLevel">
            <summary>
            The access levels (bitmapped) that are used to control the various actions that a user is allowed to perform.
            </summary>
            <remarks>
            Primarily used to control access to page manipulation functions in EPiServer, but can be used for general-purpose
            access restriction functions.
            </remarks>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.NoAccess">
            <summary>
            No access to an item
            </summary>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.Read">
            <summary>
            Read access to an item
            </summary>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.Create">
            <summary>
            Create access for an item, i e create new items below this item
            </summary>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.Edit">
            <summary>
            Change / create new versions of this item
            </summary>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.Delete">
            <summary>
            Delete this item
            </summary>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.Publish">
            <summary>
            Publish/unpublish items and versions of an item
            </summary>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.Administer">
            <summary>
            Set access rights for an item
            </summary>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.FullAccess">
            <summary>
            Full access for an item
            </summary>
        </member>
        <member name="F:EPiServer.Security.AccessLevel.Undefined">
            <summary>
            Access level not defined.
            </summary>
            <remarks>
            This enum value is reserved for internal use.
            </remarks>
        </member>
        <member name="T:EPiServer.Security.IQueryableSecurityDescriptor">
            <summary>
            Defines if Querable security descriptor.
            </summary>
        </member>
        <member name="T:EPiServer.Security.ISecurityDescriptor">
            <summary>
            The interface for a Security descriptor, i e something that allows for checking access rights.
            </summary>
        </member>
        <member name="M:EPiServer.Security.ISecurityDescriptor.HasAccess(System.Security.Principal.IPrincipal,EPiServer.Security.AccessLevel)">
            <summary>
            Determines whether the specified principal has the requested access.
            </summary>
            <param name="principal">The principal to authorize.</param>
            <param name="access">The requested access level.</param>
            <returns>
            	<c>true</c> if the specified principal has access; otherwise, <c>false</c>.
            </returns>
            <remarks>
            Note that the access level is a bitmask, i e we simply check that all specified access types
            are granted to the principal.
            </remarks>
        </member>
        <member name="M:EPiServer.Security.ISecurityDescriptor.GetAccessLevel(System.Security.Principal.IPrincipal)">
            <summary>
            Returns the access level for the specified principal.
            </summary>
            <param name="principal">The principal to check access against.</param>
            <returns>The access level.</returns>
            <remarks>
            Use this method when you want to get the union of all access types granted to this principal. This is
            most likely only used for display purposes in the user interface. Code that checks access and performs 
            different actions depending on the type of access granted should use the HasAccess method, since it 
            does what you want and has the potential for being much faster. 
            </remarks>
        </member>
        <member name="M:EPiServer.Security.IQueryableSecurityDescriptor.QueryAccess(System.Security.Principal.IPrincipal,EPiServer.Security.AccessLevel)">
            <summary>
            Queries the access.
            </summary>
            <param name="principal">The principal.</param>
            <param name="maxAccess">The max access.</param>
            <returns></returns>
        </member>
        <member name="M:EPiServer.Security.IQueryableSecurityDescriptor.QueryDistinctAccess(System.Security.Principal.IPrincipal,EPiServer.Security.AccessLevel)">
            <summary>
            Queries the distinct access.
            </summary>
            <param name="principal">The principal.</param>
            <param name="access">The access.</param>
            <returns></returns>
        </member>
        <member name="T:EPiServer.Security.ISecurable">
            <summary>
            The ISecurable interface is implemented by any object that has access restrictions.
            </summary>
            <remarks>
            In order to decouple domain objects from the access check / security management responsibilities,
            the process of checking access rights are split into two parts: first you get the security
            descriptor from the secured object, then you check access rights on the security descriptor.
            </remarks>
        </member>
        <member name="M:EPiServer.Security.ISecurable.GetSecurityDescriptor">
            <summary>
            Gets the security descriptor.
            </summary>
            <returns>An implementation of ISecurityDescriptor.</returns>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.IFieldAccess">
            <summary>
            Summary description for IFieldAccess.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.IRawFieldAccess">
            <summary>
            Summary description for IRawFieldAccess.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.Serialization.IRawFieldAccess.GetFieldValue(System.Object,System.String)">
            <summary>
            Extract value for the specified field from an object instance.
            </summary>
            <param name="obj">The object instance to read field value from.</param>
            <param name="schemaField">The field to read</param>
            <returns>The value</returns>
            <remarks>
            Note that the schemaField refers to the name the field has been given from a schema 
            (<see cref="T:EPiServer.BaseLibrary.Serialization.ISchema"/> and <see cref="T:EPiServer.BaseLibrary.Serialization.SchemaItem"/>). You need to provide some type 
            of mapping from the schema name to the actual field in the object.
            </remarks>
        </member>
        <member name="M:EPiServer.BaseLibrary.Serialization.IRawFieldAccess.SetFieldValue(System.Object,System.String,System.Object)">
            <summary>
            Set the specified field in the object instance to the given value.
            </summary>
            <param name="obj">The object instance to set field value for.</param>
            <param name="schemaField">The field to set.</param>
            <param name="value">The value to set the field to.</param>
            <remarks>
            See remarks for <see cref="M:EPiServer.BaseLibrary.Serialization.IRawFieldAccess.GetFieldValue(System.Object,System.String)"/> regarding schema mapping.
            </remarks>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.IndexedAttribute">
            <summary>
            Summary description for IndexedAttribute.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.IndexedFieldEventArgs">
            <summary>
            Summary description for IndexedFieldEventArgs.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.ISchema">
            <summary>
            A dictionary that has a unique id. Values are expected to be of type SchemaItem and keys should be strings.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.ISchemaFormatter">
            <summary>
            Summary description for ISchemaFormatter.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.ISchemaStore">
            <summary>
            Summary description for ISchemaStore.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.SchemaAttribute">
            <summary>
            Summary description for SchemaAttribute.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.SchemaFieldMappingAttribute">
            <summary>
            Summary description for SchemaFieldMappingAttribute.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.Serialization.SchemaItem">
            <summary>
            Summary description for SchemaItem.
            </summary>
        </member>
        <member name="F:EPiServer.BaseLibrary.Serialization.SchemaItem.NonexistentValue">
            <summary>
            This value is used to indicate that you tried to get the value for a field that does not exist
            in the oject. Used by <see cref="M:EPiServer.BaseLibrary.Serialization.IRawFieldAccess.GetFieldValue(System.Object,System.String)"/> since null may very well be
            a valid value for the field.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.SessionException">
            <summary>
            Summary description for SessionException.
            </summary>
        </member>
        <member name="T:EPiServer.BaseLibrary.IO.StreamConsumer">
            <summary>
            Class for copying and reading streams.
            </summary>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.StreamConsumer.ConsumeToEnd(System.IO.Stream,EPiServer.BaseLibrary.IO.StreamConsumer.StreamConsumerDelegate)">
            <summary>
            Reads a stream to its end, calling a callback method with blocks of data.
            </summary>
            <param name="input">The stream to read.</param>
            <param name="streamConsumerDelegate">A delegate to the callback method.</param>
        </member>
        <member name="M:EPiServer.BaseLibrary.IO.StreamConsumer.CopyToEnd(System.IO.Stream,System.IO.Stream)">
            <summary>
            Reads a stream to its end and writes the contents to another stream.
            </summary>
            <param name="input">The stream to read from.</param>
            <param name="output">The stream to write to.</param>
        </member>
        <member name="T:EPiServer.BaseLibrary.IO.StreamConsumer.StreamConsumerDelegate">
            <summary>
            Delegate type for the callback used by ConsumeToEnd.
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
    </members>
</doc>
